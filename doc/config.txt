* Advanced Configuration

** Server Settings

| Environment Variable | ''TVNC_ALRALL = ''__''0 \| 1''__ |
| Summary | Disable/Enable automatic lossless refresh for regions that were \
drawn using X11 functions other than ''X[Shm]PutImage()'' |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: See {ref prefix="Section ": ALR}

| Environment Variable | ''TVNC_ALRCOPYRECT = ''__''0 \| 1''__ |
| Summary | Disable/Enable automatic lossless refresh for regions that were \
drawn using CopyRect |
| Default Value | Enabled |
#OPT: hiCol=first

	Description :: See {ref prefix="Section ": ALR}

| Environment Variable | ''TVNC_COMBINERECT = ''__''{c}''__ |
| Summary | Combine framebuffer updates with more than __''{c}''__ rectangles \
into a single rectangle spanning the bounding box of all of the constituent \
rectangles |
| Default Value | 100 |
#OPT: hiCol=first

	Description :: Applications can sometimes draw many thousands of points or
	tiny lines using individual X11 calls, and this can cause the VNC server to
	send many	thousands of tiny rectangles to the VNC viewer.  The overhead
	associated with this can bog down the viewer, and in extreme cases, the
	number of rectangles may even exceed the maximum number that is allowed in a
	single framebuffer update (65534.)  Thus, if a framebuffer update contains
	more than __''{c}''__ rectangles, TurboVNC will coalesce it into a single
	rectangle that covers all of the rectangles in the update.  For applications
	that generate many tiny rectangles, increasing ''TVNC_COMBINERECT'' may
	significantly increase the number of pixels sent to the viewer, which will
	increase network usage.  However, for those same applications, lowering
	''TVNC_COMBINERECT'' will increase the number of rectangles sent to the
	viewer, which will increase the CPU usage of both the server and the viewer.

| Environment Variable | ''TVNC_ICEBLOCKSIZE = ''__''{s}''__ |
| Summary | Set the block size for the interframe comparison engine (ICE) to \
__''{s}''__ x __''{s}''__ pixels.  Setting __''{s}''__ to 0 causes the ICE to \
compare full rectangles, as TurboVNC 1.2.x did. |
| Default Value | 256 |
#OPT: hiCol=first

	Description :: If interframe comparison is enabled (see
	{ref prefix="Section ": InterframeComparison}), then TurboVNC will compare
	each rectangle of each framebuffer update on a block-by-block basis and send
	only the blocks that have changed.  This prevents large rectangles from being
	re-transmitted if only a few pixels in the rectangle have changed.  Using
	smaller block sizes can decrease network usage if only a few pixels are
	changing between updates, but using smaller block sizes can also interfere
	with the Tight encoder's ability to efficiently split rectangles into
	subrectangles, thus increasing server CPU usage (and sometimes increasing
	network usage as well, which runs counter to the purpose of interframe
	comparison.)  Setting the block size to 0 causes the ICE to compare full
	framebuffer update rectangles, as TurboVNC 1.2.x did.
	{nl}{nl}
	The default block size of 256x256 was chosen based on extensive low-level
	experiments using the same set of RFB session captures that were used when
	designing the TurboVNC encoder.  For most of those datasets, 256x256 blocks
	produced the lowest network and CPU usage, but actual mileage may vary.
	There were rare cases in which using 64x64 blocks or full-rectangle
	comparison produced better network and CPU usage.

| Environment Variable | ''TVNC_ICEDEBUG = ''__''0 \| 1''__ |
| Summary | Disable/Enable the ICE debugger |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: If interframe comparison is enabled (see
	{ref prefix="Section ": InterframeComparison}), then setting this environment
	variable to 1 will cause the interframe comparison engine (ICE) to change the
	color of duplicate screen regions without culling them from the update stream.  This
	allows you to easily see which applications are generating duplicate updates.

| Environment Variable | ''TVNC_MT = ''__''0 \| 1''__ |
| Summary | Disable/Enable multithreaded image encoding |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: See {ref prefix="Section ": Multithreading}

| Environment Variable | ''VGL_NTHREADS = ''__''{n}''__ |
| Summary | Use __''{n}''__ threads to perform image encoding |
| Default Value | __''{n}''__ = the number of CPU cores in the system |
#OPT: hiCol=first

	Description :: See {ref prefix="Section ": Multithreading}

| Environment Variable | ''TVNC_PROFILE = ''__''0 \| 1''__ |
| Summary | Disable/enable profiling output |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: If profiling output is enabled, then the TurboVNC Server will
	continuously benchmark itself and periodically print the throughput of
	various stages in its image pipeline to the Xvnc log file.

** Client Settings

| Environment Variable | ''TVNC_PROFILE = ''__''0 \| 1''__ |
| Summary | Disable/enable profiling output |
| Platforms | Un*x, Mac (Java) |
| Default Value | Disabled |
#OPT: hiCol=first

	Description :: If profiling output is enabled, then the TurboVNC Viewer will
	continuously benchmark itself and periodically print the throughput of
	various stages in its image pipeline to the console.

** Java Client Settings

| Java System Property | ''turbovnc.forcealpha = ''__''0 \| 1''__ |
| Summary | Disable/enable back buffer alpha channel |
| Default Value | Enabled if using OpenGL Java2D blitting, disabled otherwise |
#OPT: hiCol=first

	Description :: If this property is enabled, then the Java TurboVNC Viewer
	will use a TYPE_INT_ARGB_PRE (BGRA with pre-computed alpha channel)
	BufferedImage as its back buffer instead of a TYPE_INT_RGB (BGRX)
	BufferedImage.  When using OpenGL blitting in Java2D (normally accomplished
	by passing an argument of ''-Dsun.java2d.opengl=true'' to ''java''), it is
	generally faster to draw an alpha-enabled BufferedImage to the screen,
	because otherwise glDrawPixels() has to set all of the alpha values itself
	(which can cause it to revert to an unaccelerated code path in some cases.)

	!!! NOTE: this property is enabled by default when using Java 1.7 or 1.8 on
	Mac platforms, because OpenGL Java2D blitting is the only option available.
	Java 1.9 is supposed to reintroduce an accelerated 2D blitter such as existed
	in Java 1.6 for OS X.

| Java System Property | ''turbovnc.turbojpeg = ''__''0 \| 1''__ |
| Summary | Disable/enable JPEG acceleration |
| Default Value | Enabled if the libjpeg-turbo JNI library is available |
#OPT: hiCol=first

	Description :: Normally, the Java TurboVNC Viewer will try to load the
	libjpeg-turbo JNI library and use it to accelerate the decompression of
	JPEG subrectangles.  If this property is disabled, then the viewer will
	revert to using unaccelerated JPEG decompression.  This is useful mainly for
	testing and benchmarking purposes.
